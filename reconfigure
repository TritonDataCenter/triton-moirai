#!/bin/bash

#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

# Copyright 2024 MNX Cloud, Inc.

set -o errexit
set -o pipefail

if [[ -n "$TRACE" ]]; then
    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -o xtrace
fi

TOP=$(cd "$(dirname "$0")"; pwd)
# SMF doesn't give us a sane path.
PATH=/$TOP/build/node/bin:/usr/local/sbin:/usr/local/bin:/opt/local/sbin:/opt/local/bin:/usr/sbin:/usr/bin:/sbin

skel_config_dir="${TOP}/haproxy.cfg"
real_config_dir=/opt/local/etc/haproxy.cfg
self_signed_cert_dir=/opt/triton/ssl/self-signed

candidate_config_dir=$(mktemp -d /tmp/haproxy.cfg.XXXXXX)
candidate_domains=$(mktemp /tmp/domains.txt.XXXXXX)

function ensure_haproxy {
    haproxy_state=$(svcs -Ho state haproxy)
    case "$haproxy_state" in
        disabled)
            svcadm enable -s haproxy ;;
        maintenance)
            svcadm clear haproxy ;;
        online)
            # Graceful restart of haproxy to avoid disrupting any connections.
            # Don't let this fail so we don't get caught by errexit.
            pkill -USR2 -c "$(svcs -Ho ctid haproxy)" haproxy || true;;
        *)
            echo 'HAProxy non-actionable state: %s' "$haproxy_state"
            ;;
    esac
}

function configure_haproxy {
    rsync -a "${skel_config_dir}/" "${candidate_config_dir}/"
    {
        printf '#                                                  #\n'
        printf '# ## DO NOT EDIT. THIS FILE WILL BE OVERWRITTEN ## #\n'
        printf '#                                                  #\n'
    } > "${candidate_config_dir}/100-services.cfg"

    "${TOP}/parser.js" > "${candidate_config_dir}/100-services.cfg"

    if diff -qr "${real_config_dir}" "${candidate_config_dir}"; then
        echo 'Config is unchanged.'
    else
        # Config is different. Continuing.
        if haproxy -c -f "${candidate_config_dir}"; then
            # Candidate config is good.
            rsync -a --delete "${candidate_config_dir}/" "${real_config_dir}/"
        fi
    fi
    rm -rf "${candidate_config_dir:?}"
}

function configure_tls {
    cert_subject=$(mdata-get cloud.tritoncompute:certificate_name || true)
    (
        if [[ -n "$cert_subject" ]]; then
            cd /opt/triton/dehydrated
            # Convert comma separated list to space separated.
            tr ',' ' ' <<< "$cert_subject" > "$candidate_domains"
            if ! diff -q ./domains.txt "$candidate_domains"; then
                mv "$candidate_domains" domains.txt
            fi
            ./dehydrated -c
        else
            echo 'No certificate name present. Generating self-signed.'
            generate_self_signed_certificate
        fi
        if [[ -f $candidate_domains ]]; then
            rm -f "$candidate_domains"
        fi
    )
}

function generate_self_signed_certificate  {
    if [[ -f ${self_signed_cert_dir}/privkey.pem && \
          -f ${self_signed_cert_dir}/cert.pem ]]; then
        echo "TLS Certificate Exists"
    else
        echo "Generating TLS Self-signed Certificate"
        mkdir -p ${self_signed_cert_dir}
        ln -s self-signed /opt/triton/tls/default
        /opt/local/bin/openssl req -x509 -nodes -subj '/CN=*' \
            -pkeyopt ec_paramgen_curve:prime256v1 \
            -pkeyopt ec_param_enc:named_curve \
            -newkey ec -keyout ${self_signed_cert_dir}/privkey.pem \
            -out ${self_signed_cert_dir}/cert.pem -days 3650
        cat ${self_signed_cert_dir}/privkey.pem >> ${self_signed_cert_dir}/cert.pem
    fi
}

configure_haproxy
configure_tls
ensure_haproxy
